第一次学习互斥锁时感觉听不懂，思考了一下多线程的概念，有些理解了。

回顾一下线程的创造过程，一共两种方法：1. 使一个类继承Threads类。 2. 实现Runnable接口

两种方法都需要重写run()方法，从目前的知识储备来看，线程只能通过run()方法来访问其他方法。多线程的本质是同时对**同一个对象**进行多次访问，
操作代码和数据，理解这一点很关键，对理解互斥锁有帮助，要记住多线程的本质同时对同一个对象进行多次访问。

所以，锁的概念是属于对象的，即一个对象拥有一个锁，而不是一个类。

这就是为什么，如果一个类继承了Threads类，他的使用synchronized(this){}是无法实现同步的，因为这种方式创建线程时采用的是new形式，一个线程是一个对象，一个对象拥有各自的一把锁。

再说一说synchronized(this){}代码块，括号里的this指的是当前对象，他是一个参数，这个参数可以是其他对象，因为每个对象都有一个锁。只有拿到这个锁的进程才可以执行代码块里的代码，所以这里指的是只有拿到this锁的线程才可以执行里面的代码，参数不一定是对象本身，也可以是其他对象，总之要执行代码块内的代码，就必须有该对象的锁，一个对象只有一个锁，在底层是通过一个位表示的。
